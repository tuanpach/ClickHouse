-- Tests for hasAnyTokens and hasAllTokens with the third argument (tokenizer definition).
-- Covers all tokenizers: ngrams, splitByNonAlpha, splitByString, sparseGrams.

-- { echoOn }

SELECT '--- ngrams tokenizer ---';
--- ngrams tokenizer ---
-- ngrams(3) - default ngram size
SELECT hasAllTokens('abcdef', 'abc', 'ngrams(3)');
1
SELECT hasAllTokens('abcdef', ['abc', 'bcd', 'cde', 'def'], 'ngrams(3)');
1
SELECT hasAnyTokens('abcdef', 'abc', 'ngrams(3)');
1
SELECT hasAnyTokens('abcdef', ['abc', 'xyz'], 'ngrams(3)');
1
-- positive: all 3-grams present
SELECT hasAllTokens('abcdef', ['abc', 'def'], 'ngrams(3)');
1
-- negative: not all 3-grams present
SELECT hasAllTokens('abcdef', ['abc', 'xyz'], 'ngrams(3)');
0
-- positive: at least one 3-gram present
SELECT hasAnyTokens('abcdef', ['xyz', 'cde'], 'ngrams(3)');
1
-- negative: no 3-gram present
SELECT hasAnyTokens('abcdef', ['xyz', 'zzz'], 'ngrams(3)');
0
-- ngrams with different sizes
SELECT hasAllTokens('abcdef', 'ab', 'ngrams(2)');
1
SELECT hasAllTokens('abcdef', ['ab', 'cd', 'ef'], 'ngrams(2)');
1
SELECT hasAnyTokens('abcdef', ['xy', 'ab'], 'ngrams(2)');
1
SELECT hasAnyTokens('abcdef', ['xy', 'yz'], 'ngrams(2)');
0
SELECT hasAllTokens('abcdefgh', 'abcd', 'ngrams(4)');
1
SELECT hasAllTokens('abcdefgh', ['abcd', 'efgh'], 'ngrams(4)');
1
SELECT hasAnyTokens('abcdefgh', ['xxxx', 'defg'], 'ngrams(4)');
1
SELECT hasAnyTokens('abcdefgh', ['xxxx', 'yyyy'], 'ngrams(4)');
0
-- ngrams without explicit size (default = 3)
SELECT hasAllTokens('abcdef', 'abc', 'ngrams');
1
SELECT hasAnyTokens('abcdef', 'xyz', 'ngrams');
0
-- with materialize
SELECT hasAllTokens(materialize('abcdef'), 'abc', 'ngrams(3)');
1
SELECT hasAllTokens(materialize('abcdef'), ['abc', 'xyz'], 'ngrams(3)');
0
SELECT hasAnyTokens(materialize('abcdef'), 'abc', 'ngrams(3)');
1
SELECT hasAnyTokens(materialize('abcdef'), ['xyz', 'zzz'], 'ngrams(3)');
0
SELECT hasAllTokens(materialize('abcdef'), ['abc', 'bcd', 'cde', 'def'], 'ngrams(3)');
1
SELECT hasAnyTokens(materialize('abcdef'), ['xyz', 'cde'], 'ngrams(3)');
1
SELECT '--- splitByNonAlpha tokenizer ---';
--- splitByNonAlpha tokenizer ---
-- splitByNonAlpha splits by non-alphanumeric characters
SELECT hasAllTokens('hello world', 'hello', 'splitByNonAlpha');
1
SELECT hasAllTokens('hello world', ['hello', 'world'], 'splitByNonAlpha');
1
SELECT hasAllTokens('hello world', 'hello world', 'splitByNonAlpha');
1
-- negative: token not present
SELECT hasAllTokens('hello world', ['hello', 'foo'], 'splitByNonAlpha');
0
SELECT hasAnyTokens('hello world', ['foo', 'world'], 'splitByNonAlpha');
1
SELECT hasAnyTokens('hello world', ['foo', 'bar'], 'splitByNonAlpha');
0
-- tokens separated by various non-alpha characters
SELECT hasAllTokens('key=value;data', ['key', 'value', 'data'], 'splitByNonAlpha');
1
SELECT hasAnyTokens('key=value;data', ['missing', 'data'], 'splitByNonAlpha');
1
SELECT hasAnyTokens('key=value;data', ['missing', 'absent'], 'splitByNonAlpha');
0
-- with materialize
SELECT hasAllTokens(materialize('hello world'), ['hello', 'world'], 'splitByNonAlpha');
1
SELECT hasAllTokens(materialize('hello world'), ['hello', 'missing'], 'splitByNonAlpha');
0
SELECT hasAnyTokens(materialize('hello world'), ['missing', 'world'], 'splitByNonAlpha');
1
SELECT hasAnyTokens(materialize('hello world'), ['foo', 'bar'], 'splitByNonAlpha');
0
-- using internal name
SELECT hasAllTokens('hello world', ['hello', 'world'], 'tokenbf_v1');
1
SELECT '--- splitByString tokenizer ---';
--- splitByString tokenizer ---
-- splitByString with default separator (space)
SELECT hasAllTokens('hello world', ['hello', 'world'], 'splitByString');
1
SELECT hasAllTokens('hello world', ['hello', 'missing'], 'splitByString');
0
SELECT hasAnyTokens('hello world', ['missing', 'world'], 'splitByString');
1
SELECT hasAnyTokens('hello world', ['foo', 'bar'], 'splitByString');
0
-- splitByString with custom separators
SELECT hasAllTokens('key=value|data', ['key', 'value', 'data'], 'splitByString([\'=\', \'|\'])');
1
SELECT hasAllTokens('key=value|data', ['key', 'missing'], 'splitByString([\'=\', \'|\'])');
0
SELECT hasAnyTokens('key=value|data', ['missing', 'data'], 'splitByString([\'=\', \'|\'])');
1
SELECT hasAnyTokens('key=value|data', ['foo', 'bar'], 'splitByString([\'=\', \'|\'])');
0
-- splitByString with multi-character separator
SELECT hasAllTokens('hello::world::test', ['hello', 'world', 'test'], 'splitByString([\'::\'])');
1
SELECT hasAnyTokens('hello::world::test', ['missing', 'world'], 'splitByString([\'::\'])');
1
SELECT hasAnyTokens('hello::world::test', ['missing', 'absent'], 'splitByString([\'::\'])');
0
-- with materialize
SELECT hasAllTokens(materialize('key=value|data'), ['key', 'value', 'data'], 'splitByString([\'=\', \'|\'])');
1
SELECT hasAllTokens(materialize('key=value|data'), ['key', 'missing'], 'splitByString([\'=\', \'|\'])');
0
SELECT hasAnyTokens(materialize('hello::world'), ['missing', 'world'], 'splitByString([\'::\'])');
1
SELECT hasAnyTokens(materialize('hello::world'), ['missing', 'absent'], 'splitByString([\'::\'])');
0
SELECT '--- sparseGrams tokenizer ---';
--- sparseGrams tokenizer ---
-- sparseGrams with default parameters (min_length=3, max_length=100)
SELECT hasAllTokens('abcdef', 'abcdef', 'sparseGrams');
1
SELECT hasAnyTokens('abcdef', 'abcdef', 'sparseGrams');
1
SELECT hasAnyTokens('abcdef', 'xyzxyz', 'sparseGrams');
0
-- sparseGrams with explicit parameters
SELECT hasAllTokens('abcdefghij', 'abcdefghij', 'sparseGrams(3, 10)');
1
SELECT hasAnyTokens('abcdefghij', 'xyzxyzxyzx', 'sparseGrams(3, 10)');
0
-- sparseGrams with all three parameters (min_length, max_length, min_cutoff_length)
SELECT hasAllTokens('abcdefghij', 'abcdefghij', 'sparseGrams(3, 10, 5)');
1
SELECT hasAnyTokens('abcdefghij', 'xyzxyzxyzx', 'sparseGrams(3, 10, 5)');
0
-- with materialize
SELECT hasAllTokens(materialize('abcdef'), 'abcdef', 'sparseGrams');
1
SELECT hasAnyTokens(materialize('abcdef'), 'abcdef', 'sparseGrams');
1
SELECT hasAnyTokens(materialize('abcdef'), 'xyzxyz', 'sparseGrams');
0
-- using internal bloom filter index name
SELECT hasAllTokens('abcdef', 'abcdef', 'sparse_grams');
1
SELECT hasAnyTokens('abcdef', 'xyzxyz', 'sparse_grams');
0
SELECT '--- mixed: needles as string vs array ---';
--- mixed: needles as string vs array ---
-- String needles are tokenized with the same tokenizer
SELECT hasAllTokens('hello world foo', 'hello world', 'splitByNonAlpha');
1
SELECT hasAnyTokens('hello world foo', 'bar baz world', 'splitByNonAlpha');
1
SELECT hasAnyTokens('hello world foo', 'bar baz qux', 'splitByNonAlpha');
0
-- Array needles are used directly as tokens
SELECT hasAllTokens('hello world foo', ['hello', 'world'], 'splitByNonAlpha');
1
SELECT hasAnyTokens('hello world foo', ['bar', 'world'], 'splitByNonAlpha');
1
SELECT hasAnyTokens('hello world foo', ['bar', 'baz'], 'splitByNonAlpha');
0
SELECT '--- edge cases ---';
--- edge cases ---
-- empty string
SELECT hasAllTokens('', 'abc', 'ngrams(3)');
0
SELECT hasAnyTokens('', 'abc', 'ngrams(3)');
0
SELECT hasAllTokens('', ['abc'], 'ngrams(3)');
0
SELECT hasAnyTokens('', ['abc'], 'ngrams(3)');
0
-- empty needles
SELECT hasAllTokens('hello', '', 'splitByNonAlpha');
0
SELECT hasAnyTokens('hello', '', 'splitByNonAlpha');
0
SELECT hasAllTokens('hello', [], 'splitByNonAlpha');
0
SELECT hasAnyTokens('hello', [], 'splitByNonAlpha');
0
-- materialize on empty
SELECT hasAllTokens(materialize(''), 'abc', 'ngrams(3)');
0
SELECT hasAnyTokens(materialize(''), ['abc'], 'ngrams(3)');
0
SELECT hasAllTokens(materialize('hello'), '', 'splitByNonAlpha');
0
SELECT hasAnyTokens(materialize('hello'), [], 'splitByNonAlpha');
0
SELECT '--- duplicate needles ---';
--- duplicate needles ---
SELECT hasAllTokens('foo bar baz', ['foo', 'foo', 'foo', 'bar', 'bar', 'bar']);
1
SELECT hasAnyTokens('foo bar baz', ['foo', 'foo', 'foo', 'bar', 'bar', 'bar']);
1
SELECT hasAllTokens(lower(materialize('Hello world')), [lower(toLowCardinality('Hello'))]);
1
--- negative: invalid tokenizer ---
